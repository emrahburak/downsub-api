WEBVTT
Kind: captions
Language: en

00:00:00.030 --> 00:00:01.990
functional programming is

00:00:01.990 --> 00:00:03.990
essentially kind of programming where

00:00:05.140 --> 00:00:06.700
functions don't have side effects

00:00:06.700 --> 00:00:10.500
So what does it mean when you call a function you give it some inputs?

00:00:10.719 --> 00:00:16.079
And it will return some output and that's all that it does it doesn't modify the inputs

00:00:16.180 --> 00:00:20.069
It doesn't do something on the side people often talk about firing the missiles

00:00:20.070 --> 00:00:21.189
It can't do that

00:00:21.189 --> 00:00:26.819
the entire behavior of the function you can see by [looking] at what the inputs were and what the apple was that was generated and

00:00:27.189 --> 00:00:29.519
if you [program] [in] that style, then functions are

00:00:30.490 --> 00:00:32.910
you know you know a lot [about] their behavior and

00:00:33.160 --> 00:00:38.250
Many of the mistakes that are easy to make when you program in more conventional programming languages

00:00:38.250 --> 00:00:44.219
is that [you] forget about some effects that a function has in addition to returning its result and

00:00:44.620 --> 00:00:51.539
What you forget about those effects then they can lead to very difficult to find bugs and a lot of wasted time?

00:00:54.640 --> 00:00:57.149
What did I get used for these languages?

00:00:58.270 --> 00:01:05.459
Quite a variety of things they've made a lot of impact on the server side of internet applications. So for example haskell

00:01:05.460 --> 00:01:11.640
Which is the language that I played a part in designing. That's now used for all the spam filtering on Facebook

00:01:12.340 --> 00:01:18.119
now when I heard that first of all I said, I didn't think there was spam on Facebook and

00:01:19.420 --> 00:01:22.710
Sally Marlowe, the man is now in charge of this said to me exactly

00:01:23.530 --> 00:01:25.530
That's how good we [are]

00:01:25.990 --> 00:01:28.259
All of that is running in Haskell nowadays

00:01:28.780 --> 00:01:33.210
another example would be airline that's another functional [programming] [language] which I'm working with a lot at the moment [and]

00:01:34.600 --> 00:01:39.089
Airline was used to implement. Whatsapp always everybody uses whatsapp at some point

00:01:39.369 --> 00:01:46.859
that's all airline code running behind it there are other examples Twitter's code is built using scala which is a

00:01:47.320 --> 00:01:50.519
programming language that I think was heavily inspired by Haskell, but

00:01:51.579 --> 00:01:53.579
integrates very well with Java and

00:01:54.100 --> 00:01:56.100
but it's also mostly functional and

00:01:56.409 --> 00:02:00.749
So you know many of the services that we use [everyday] are actually running functional code in the background

00:02:00.850 --> 00:02:05.939
You've just mentioned then you had a hand in the development of haskell. Where did you start?

00:02:05.939 --> 00:02:08.878
[did] you have a big team that you weren't where tell me about that? Oh?

00:02:09.520 --> 00:02:11.520
so that was interesting and

00:02:12.160 --> 00:02:18.059
so when I first got in functional programming there were small number of people working on it at different universities around the world and

00:02:19.120 --> 00:02:25.530
In those days you couldn't really get hold of a functional programming language from somewhere else you had to write your own compiler

00:02:25.930 --> 00:02:30.420
So many of us around the [world] were doing that and then after [a] while

00:02:30.940 --> 00:02:36.179
We realized and it was a man called Paul [hugh] deck yale university took the first initiative to this

00:02:36.760 --> 00:02:42.149
We realized that we were all working with very much the same kind of programming language

00:02:42.760 --> 00:02:46.320
But because we each had our own compiler. We couldn't share any code

00:02:46.360 --> 00:02:47.670
We couldn't share our results

00:02:47.670 --> 00:02:53.850
And that just seemed [like] a waste of effort so that led to the proposal [tooned] just

00:02:54.280 --> 00:03:00.239
Take the common core [of] what we were all doing put it together and [designer] a programming language that we all use

00:03:00.640 --> 00:03:03.839
Which became haskell what where did the name come from then?

00:03:04.360 --> 00:03:06.360
It's actually named after

00:03:06.880 --> 00:03:08.739
Haskell Curry who was

00:03:08.739 --> 00:03:15.929
One of the early logicians who work with with lambda calculus the first time that the committee that was formed designed the language got together?

00:03:16.239 --> 00:03:18.659
then we decided we had to choose a name and

00:03:19.209 --> 00:03:21.809
nobody really knew [what] to choose so we

00:03:23.380 --> 00:03:26.790
Everybody was allowed to write up one proposal on the blackboard

00:03:26.790 --> 00:03:27.190
and

00:03:27.190 --> 00:03:33.269
Then everybody was allowed to go round and cross off one proposal now you might think that we would end up with zero names that

00:03:33.269 --> 00:03:35.519
Way, but no there was one name that

00:03:36.580 --> 00:03:39.299
Survived and it was curry

00:03:40.150 --> 00:03:41.860
named after

00:03:41.860 --> 00:03:43.390
Haskell curry

00:03:43.390 --> 00:03:47.160
So that was fine. We thought okay the new language will be called curry and

00:03:47.980 --> 00:03:50.220
This is last thing in the evening. So we all went to bed

00:03:51.100 --> 00:03:57.299
which meant we had a chance to sleep on it and next morning one of us realized that one of the

00:03:58.360 --> 00:04:02.429
Abstract machines that was very popular at that time was called the Tim

00:04:03.640 --> 00:04:05.640
Tim curry

00:04:08.230 --> 00:04:15.390
Oh dear [that] [wouldn't] be good and so we decided to call it haskell instead, so it's still named after haskell curry

00:04:15.400 --> 00:04:19.979
But his first name rather than second from what I've [seen] when you look at a functional program

00:04:19.979 --> 00:04:27.089
It is very much like a mathematical equation am [I] right with that. Yes, that's right. So one of the things is that like mathematics

00:04:28.360 --> 00:04:33.270
Functional programs will satisfy what we call laws for example in mathematics if you see

00:04:33.640 --> 00:04:39.899
x plus y you can always replace it by y plus x if that's more convenient and in

00:04:40.450 --> 00:04:47.069
Functional programs then very often you may be able to replace one program by another so you have different ways of expressing the same thing

00:04:47.070 --> 00:04:51.659
And you can replace one by the other which you may want to do because one of them may be much more

00:04:51.970 --> 00:04:53.890
efficient than the other

00:04:53.890 --> 00:04:55.390
and you know

00:04:55.390 --> 00:04:59.580
that that replacement will not change the overall behavior of your program and

00:05:00.250 --> 00:05:05.429
So we find that these laws extremely important for reasoning about programs and they can let you

00:05:06.010 --> 00:05:12.899
Rewrite your program quite freely in order to try and improve its performance for example and be sure that you're not introducing bugs

00:05:12.900 --> 00:05:15.120
[I'm] assuming that the same kind of

00:05:15.520 --> 00:05:22.020
Mechanics are happening somewhere at some level on the computers with any other programming language though is a [repeal] for this is it slow is

00:05:22.020 --> 00:05:24.930
It faster. What's that? What's the deal? Oh, well, so

00:05:25.720 --> 00:05:32.459
Functional programming languages take care of a lot [of] the implementation details that an older programming languages you have to do

00:05:32.620 --> 00:05:34.679
manually for example memory management

00:05:35.349 --> 00:05:36.360
but nowadays

00:05:36.360 --> 00:05:44.340
It's very popular to use languages like even Java for example which builds memory management into the programming language functional languages do that too

00:05:45.729 --> 00:05:50.999
Very often there is some kind of performance penalty for this and that has meant that

00:05:51.729 --> 00:05:57.899
One of the very active parts of functional programming research has been developing compilers that [can] give good performance

00:05:58.419 --> 00:06:00.749
Despite the fact that you're programming at a higher level

00:06:01.630 --> 00:06:02.740
nowadays

00:06:02.740 --> 00:06:08.700
Code written and functional languages can be as fast as or sometimes faster than code written in conventional programming languages

00:06:08.919 --> 00:06:12.059
one of the very nice benefits of functional program by the way

00:06:12.909 --> 00:06:17.969
is that it's always safe to evaluate two independent expressions in Parallel and

00:06:19.419 --> 00:06:25.848
That's because functions have no side effects so you can all the functions going to do is convert inputs to outputs

00:06:25.860 --> 00:06:30.889
And you can have two of those computations going on at the same time they cannot interfere

00:06:32.190 --> 00:06:34.050
Whereas if you use

00:06:34.050 --> 00:06:40.490
Programming languages in which each function may be modifying data somewhere else at the same time then you can't tell whether or not

00:06:40.680 --> 00:06:46.910
Two functions will interfere they're very likely to and that means that when you want to make programs run in parallel

00:06:47.220 --> 00:06:51.349
When you want to make them use more than one of the cores in your laptop

00:06:51.810 --> 00:06:57.739
Then it's much easier to do that if you start with a functional program and that can give a performance benefit over and above

00:06:57.900 --> 00:07:01.370
What conventional programming languages have I've heard as well?

00:07:01.409 --> 00:07:07.459
there is [a] possibility to make hack-proof code using functional programming is that something you could tell me about or

00:07:08.400 --> 00:07:13.940
Yes, so there is a lot of work in trying to make of the cannot be hacked of for example. Can't leak

00:07:14.699 --> 00:07:16.620
confidential Data and

00:07:16.620 --> 00:07:21.679
There are people who are working on programming languages that will provide some guarantees about that

00:07:22.199 --> 00:07:28.639
one of the quite successful approaches is to build a library into haskell in fact that can be used for

00:07:29.340 --> 00:07:32.000
enforcing in particular Privacy constraints

00:07:32.580 --> 00:07:34.729
So yes, there's work [going] on in [that] area

00:07:35.070 --> 00:07:37.219
We're going to talk about things like your quick check

00:07:37.219 --> 00:07:41.779
And you know that we've already filmed some stuff on that and what do you up to? What do you do?

00:07:41.780 --> 00:07:43.289
What's what's next for you?

00:07:43.289 --> 00:07:46.218
So I'm devoting most of my time to quick check nowadays

00:07:46.770 --> 00:07:51.949
where the basic idea is not to write tests by hand because

00:07:54.270 --> 00:07:56.270
Because basically it doesn't work

00:07:56.490 --> 00:08:01.789
Software is so complex that to make sure there are no bugs in it you have to try all kinds of weird

00:08:01.949 --> 00:08:08.899
Combinations, and there are just too many combinations to try for people to be able to try them all so really the only way to

00:08:09.810 --> 00:08:11.340
ensure that you

00:08:11.340 --> 00:08:13.669
Avoid these bugs is to generate tests instead

00:08:13.819 --> 00:08:16.609
That's what quick check does it lets you write test

00:08:16.610 --> 00:08:23.090
Code that says what your program [should] do and then it generates as many tests as you want to check that it does

00:08:23.909 --> 00:08:28.009
And I've been working with quick check for many years now [10] years ago

00:08:28.009 --> 00:08:31.098
I founded a company that is commercializing quick check

00:08:31.099 --> 00:08:34.039
And that's been huge fun because it means I get [to] apply

00:08:34.380 --> 00:08:42.140
this technology to all of real problems all kinds [of] different kinds of software, and that's been a huge learning experience for me and a

00:08:42.959 --> 00:08:44.959
Tremendous source of

00:08:45.510 --> 00:08:48.830
Research problems when we find oh, it's hard to apply it in this case well

00:08:48.830 --> 00:08:52.459
There's a research [property] to solve so [as] a professor and a researcher

00:08:52.459 --> 00:08:58.219
It's given me all kinds of new ideas for problems to work on which which has been very very stimulating

00:08:59.579 --> 00:09:01.380
and

00:09:01.380 --> 00:09:08.149
the value of y at this position is going to be some polynomial that we have to find which is a

00:09:08.640 --> 00:09:11.689
x cubed plus [be] x squared

00:09:12.420 --> 00:09:18.680
Plus C. X plus d. There are four unknowns here x we know because we're going between no [1] 1

